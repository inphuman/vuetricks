---
layout: post
title: Использование Composition API в качестве альтернативы Vuex
tags: [Composition API, Vuex]
comments: false
---

Изменение состояния пользовательского интерфейса без необходимости обновления страницы стало одним из стандартов в современных
веб-приложениях. А в разработке некоторые из этих состояний часто используются многократно во многих местах. Поэтому,
чтобы уменьшить повторение написания одного и того же состояния, мы сделаем состояние доступным во многих местах -
**глобальное состояние**. Еще одна причина, по которой нам нужно это глобальное состояние, заключается в том, что изменения
в пользовательском интерфейсе иногда зависят от конкретных состояний, например, пользовательский интерфейс в **части A**
изменится, когда сработает состояние в пользовательском интерфейсе **части B**.

В React для задания глобального состояния и потока изменений часто используется Redux. Аналогично с Vue, в котором
используется Vuex. Теперь использование Redux/Vuex является стандартом, потому что глобальное
состояние - это типовая вещь в современных веб-приложениях.

Когда Vue представил свою последнюю версию, одной из главных особенностей стало **Vue Composition API**.

Composition API дает разработчикам больше свободы в создании компонентов, включая использование реактивных свойств вне
компонентов. В этой статье рассказывается о том, как используется composition API в качестве альтернативы **Vuex** при
создании глобального управления состоянием.

> В этой статье используется **Vue 2** с помощью библиотеки **vue-composition-api**. Если вы используете **Vue 3**, эта функция
> должна быть включена.

Для реализации мы создали композитный каталог для структуры папок, чтобы хранить все файлы состояний - можно также
называть их композитами. Мы используем префикс `use-` в качестве маркера для именования файла, который используется для
управления состоянием.

![Композитный каталог для структуры папок]({{ site.baseurl
}}/assets/img/posts/1_G5ODDA7cPDpsEUdACvP38g.png)

Возьмем, к примеру, файл **useUser**. Само именование не имеет ограничений, но мы стараемся использовать префикс, чтобы
обозначить, что это композитный файл. В этом файле мы создаем структуру, почти аналогичную Vuex. Состояние для
реактивных свойств, метод для изменения значения состояния и метод диспетчеризации.

```js
import {reactive, toRefs} from "@vue/composition-api";

const state = reactive({
  userData: {}
})

export default () => {
  const setUserData = (userData) => {
    state.userData = userData;
  }

  const fetchUserData = async () => {
    const userData = await fetch('/api/user/data').then(res => res.json());
    setUserData(userData);
  }

  return {
    ...toRefs(state),
    fetchUserData
  }
}
```

Вот и все! Теперь мы можем использовать **userData** в любом компоненте, который нам нужен. Мы также можем вызвать метод
fetchUserData того компонента, которому он требуется. Как и в Vuex, мы хотим, чтобы значение состояния изменялось только
этим **setUserData**. Чтобы предотвратить изменение значения этого состояния за пределами, мы можем добавить
read-only к toRefs, чтобы значение в этом состоянии не могло быть изменено за пределами.

Затем мы будем использовать этот файл в одном из созданных нами компонентов. В этом примере мы пытаемся получить данные
пользователя с Github, а затем отобразить их на странице.

```vue
<template>
  <div class="user">
    <div class="user__avatar">
      <img :src="userData.avatar" alt="">
    </div>
    <div class="user__info">
      <span class="user__name">{{ userData.name }}</span>
    </div>
  </div>
</template>

<script>
import { useUser } from '@/composable'
import { onBeforeMount } from "@vue/composition-api";

export default {
  name: "User",
  setup () {
    const { userData, fetchUserData } = useUser()
    onBeforeMount(() => {
      fetchUserData()
    })
    return {
      userData
    }
  }
}
</script>
```

**Совместное использование между модулями**

Допустим, ваше веб-приложение состоит из нескольких модулей пользовательского интерфейса.

Мы можем создать composable в контейнере UI, а затем сделать файл composable глобальным свойством в вашем приложении
Vue. Затем мы можем получить к нему доступ через оператор
свойства с помощью **Vue.prototype**.

```js
import Vue from 'vue'
import VueCompositionAPI from '@vue/composition-api'
import App from './App.vue'
import { useUser } from "@/composable"

Vue.use(VueCompositionAPI)

Vue.config.productionTip = false

// property name is up to you
Vue.prototype.$useUser = useUser()

new Vue({
  render: h => h(App),
}).$mount('#app')
```

Любой компонент модуля, которому нужны эти данные, может получить к ним доступ через **Context root.$useUser**

```vue
<script>
export default {
  name: "User",
  setup (props, { root }) {
    const { userData } = root.$useUser

    return {
      userData
    }
  }
}
</script>
```

Каждый раз, когда происходит изменение данных состояния в контейнере пользовательского интерфейса, все компоненты
модуля, которые используют эти данные, также будут обновлены.

## Заключение

**Composition API** обеспечивает гибкость при создании глобальных состояний. Мы также можем проявить творческий подход и
создать пользовательские функции с этими композиционными файлами в соответствии с потребностями нашего приложения, не
придерживаясь правил, предусмотренных Vuex. На самом деле, мы также можем сделать композицию как замену миксинам.

Однако, используя этот метод, все еще можно смешивать и сочетать с Vuex, если это необходимо. Это просто пример того,
как мы можем создать глобальное состояние и разделить его между несколькими компонентами - даже модулями - без
использования Vuex.


